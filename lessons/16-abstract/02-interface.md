Бывает так, что нам нужно только описать внешний констракт программной сущности, не закладывая никаких деталей реализации. Например, когда реализации настолько различны, что не будут иметь ничего общего между собой.

Чтобы это реализовать, мы могли бы завести абстрактный класс, в котором есть только публичные абстрактные методы. Однако тут возникает проблема, в ситуации когда нам по объективным причинам необходимо отнаследоваться от какого-то другого класса. Ведь в Java, как мы помним, множественное наследование запрещено.

В качестве альтернативы абстрактному классу у которого все методы публичные и абстрактные, в Java заведена отдельная сущность Interface (интерфейс). 

Все методы интерфейса, по определению публичные и абстрактные, поэтому явно писать данные модификаторы не требуется. Поля в интерфейсе могут быть только публичные статические финальные (public static final), т.е. по сути константы. Ничего непубличного в интерфейсе объявить нельзя.

Интерфейс служит для объявления контракта объекта по отношению к внешнему миру.

Реализуемые классом интерфейсы перечисляются после ключевого слова implements через запятую. Причем класс может реализовывать интерфейсы в дополнение к наследованию.

Совсем простые интерфейсы с одним абстрактный методом, называются функциональными. 
```
@FunctionalInterface
public interface Runnable {

    void run();
}
```
Это можно дополнительно подчеркнуть поставив анотацию @FunctionalInterface. При наличии такой анотации, компилятор проверит правда ли в интерфейсе единственный абстрактный метод, и если нет, то выдаст ошибку. 
