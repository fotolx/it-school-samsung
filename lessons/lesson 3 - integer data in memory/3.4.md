# Поразрядные операции
Всем известно, что информация представляется в компьютере в двоичном виде нулями и единицами, битами. Однако, доступ к конкретным нулям и единицам невозможен. Прочитать или записать можно только сразу байт, а команд для чтения и записи бита не существует.

Байт — это минимальная единица адресации компьютерной памяти. Для большинства современных компьютеров это восемь бит. 

Но есть команды, которые работают с каждым битом числа. Например, возможно заменить все биты в числе на противоположные. Если у нас есть два байта, то мы можем сделать логическую операцию И, ИЛИ или исключающее ИЛИ с каждой парой битов этих двух байтов. Это так называемые поразрядные операции.

Рассмотрим их подробно и сразу поговорим о применениях.
## Побитовое отрицание (NOT)
Обозначается символом ~  
Это унарная операция, которая меняет каждый бит на противоположный.
```java
  int i = 123;
  System.out.println(~i); // -124
```

## Побитовое И (AND)
Обозначается символом &  
Эта операция выставляет значение бита в 1 только в том случае, если соответствующие биты в первом и втором числе равны 1 одновременно.
<pre>
& 01111011 
  11001000
  ________
  01001000
</pre>
Побитовое И зачастую применяют для того, чтобы узнать какое значение 0 или 1 стоит в определенном бите числа.  
Тот бит, значение которого необходимо узнать, устанавливается в 1, остальные в 0. Полученное таким образом число называют маской.  
Выполняют операцию побитового И между числом и маской.  
Результат даст информацию о конкретном бите числа.

Пример 1.7  
Пусть нужно узнать 0 или 1 содержится во втором бите числа 101.
```java
  int i = 101;
  int mask = 4; 
  int result = i & mask;
  System.out.println(result > 0 ? "YES" : "NO"); \\ YES
```

<pre>
       ? 
& 01100101 // 101
  00000100 // 4
  ________
  00000100 // 4
</pre>

## Побитовое ИЛИ (OR)
Операция обозначается символом |  
Выставляет значение 1, если хотя бы один соответствующий бит в первом или во втором числе установлен в 1.
<pre>
| 01111011
  11001000
  ________
  11111011
</pre>

При помощи масок можно не только узнать, чему равно значение конкретного бита числа, но и установить его значение:
```java
  int i = 10;
  int mask = 4; 
  i | mask;
```
Все биты результата будут такими же, что и в исходном числе, кроме второго. Второй бит гарантированно станет единицей.

## Исключающее ИЛИ (XOR)
Обозначается символом ^  
Эта операция выставляет значение в 1, если соответствующий бит равен 1 только в одном из операндов, но не одновременно.
<pre>
^ 01111011
  11001000
  ________
  10110011
</pre>

Операция XOR имеет много практических применений. Самое известное и часто применяемое из которых — шифрование. Если примерить эту операцию к значению с каким-то ключом (другим значением), первое изменится, но при повторном применении восстанавливается.

Например:  
5 ^ 7 → 2 (значение зашифровалось)  
2 ^ 7 → 5 (используя ключ, можно расшифровать)

Cимволы текста можно рассматривать как их числовые коды.

Идея шифрования при помощи XOR проста: выполним операцию XOR каждого символа c ключом. Текст станет нечитаемым — зашифруется. Получатель, знающий ключ, сможет легко восстановить текст, опять выполняя операцию XOR c каждым символом с тем же ключом. Конечно, ключ можно подобрать. Но систему можно улучшить, если выбирать для каждого шифруемого символа новый ключ из известной передающему и принимающему последовательности. Например, можно шифровать при помощи текста этого пособия. В этом случае пособие выступает в роли некого сложного ключа. Расшифровка будет возможна, только если злоумышленник будет знать, как зашифровано сообщение и иметь это пособие. Такой способ кодирования называется «одноразовый блокнот».

## Знаковый оператор сдвига влево
Обозначаются символами <<

Операция, в результате которой все биты первого операнда смещаются влево и число справа дополняется нулем. Это операция повторяется столько раз, сколько задано вторым операндом. Один сдвиг влево соответствует умножению на 2.
```java
  int i = 5 << 3;
  System.out.println(i); // 40
```

## Знаковый оператор сдвига вправо
Обозначается символами >>

Операция, в результате которой все биты первого операнда смещаются вправо и число слева дополняется нулем, если число положительное, и единицей, если отрицательное. Это повторяется столько раз, сколько задано вторым операндом. Один сдвиг вправо соответствует делению на 2. Если делится нечетное число, то остаток отбрасывается для положительных чисел и сохраняется для отрицательных.
```java
  System.out.println(42 >> 2); // 10
  System.out.println(-42 >> 2); // -11
```

## Беззнаковый оператор сдвига
Операция, в результате которой все биты первого операнда смещаются вправо и число слева дополняется нулем, даже если операция выполняется с отрицательными числами. Операция повторяется столько раз, сколько задано вторым операндом.
Отсюда и название оператора — беззнаковый. В результате применения оператора всегда получается положительное число, так как в Java левый бит отвечает за знак числа. Операция так же, как и знаковый оператор сдвига вправо, соответствует делению числа на два за исключением первого сдвига в отрицительном числе.
```java
  System.out.println(-123 >>> 1); // 2147483586
```
