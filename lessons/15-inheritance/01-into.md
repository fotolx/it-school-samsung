Одна из фундаментальных концепций ООП это наследование. Речь идет о том, чтобы классы создавать не с нуля, а наследуя или расширяя другие классы.

Наследование в Java обозначается ключевым словом extends. Наследоваться можно только от одного класса. 

Унаследованный класс автоматически получает все поля и методы базового класса. Пользоваться ими с учетом модификатора доступа может как он сам, так и другие классы программы. Причем совершенно не важно, объявлено ли поле или метод непосредственно в классе или в одном из его родительских классов. Иерархия наследования может быть произвольной глубины. 

Сравните. Метод intValue() определен в классе BigDecimal. Метод shortValue() объявлен в его родительском классе Number. Имея на руках экземпляр bigDecimal, мы можем вызывать на нем как intValue(), так и shortValue(). Не задумываясь о том на каком уровне иерархии наследования объявлены эти методы. Работа с ними выглядит обсалютно одинакого. 

В классе-наследнике можно добавлять поля и методы, тем самым расширяя возможности базового класса. Кроме того методы можно переопределять, т.е. в классе-наследнике можно завести метод с таким же именем и параметрами как в базовом классе. 

При этом тип возвращаемого значения может совпадать либо быть подклассом типа возвращаемого базовым методом. А так же модификатор доступа может быть либо тем же, либо более открытым. Если эти условия выполнены, то метод класса наследника заменит собой одноименный метод из базового класса. 

В следующем примере, StringBuilder наследуются от некоего AbstractStringBuilder и переопределяет его метод append(String str), принимающий строку. При этом возвращаемый тип отличается. Но переопределение является корректным, так как возвращаемый тип StringBuilder является подклассом возвращаемого базовым методом AbstractStringBuilder. А вот если бы мы стали здесь возвращать какой-нибудь int или String, то код бы не скомпилировался. 

Хорошая практика, ставить на переопределенных методах аннотацию @Override. Она явно декларирует ваше намерение переопределить одноименный метод базового класса.

Это может показаться избыточным, ведь переопределение происходит независимо от наличия аннотации. Однако это полезно для дополнительной самопроверки. Например можно ошибиться в имени метода, или в его параметрах, и таким образом создать самостоятельный метод не перекрывающий метод базового класса. Или объявление базового класса, может изменится без вашего ведома, и сигнатуры методов разойдутся. При наличии аннотации @Override компилятор сразу укажет вам на эту проблему. 

